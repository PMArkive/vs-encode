import abc
from ..config import FileInfo
from ..language import Lang
from ..types import AnyPath
from ..vpathlib import CleanupSet, VPath
from abc import ABC, abstractmethod
from enum import Enum
from typing import Iterable, List, Literal, MutableSequence, NoReturn, Optional, Sequence, Tuple, overload

class _AbstractTrack(Sequence[str], ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def __init__(self): ...
    @overload
    def __getitem__(self, __x: int) -> str: ...
    @overload
    def __getitem__(self, __x: slice) -> Tuple[str, ...]: ...
    def __len__(self) -> int: ...

class Track(_AbstractTrack):
    path: VPath
    opts: Tuple[str, ...]
    def __init__(self, path: AnyPath, *opts: str) -> None: ...

class MediaTrack(Track):
    name: Optional[str]
    lang: Lang
    def __init__(self, path: AnyPath, name: Optional[str] = ..., lang: Lang = ..., tid: int = ..., *opts: str) -> None: ...

class VideoTrack(MediaTrack): ...
class AudioTrack(MediaTrack): ...
class SubtitleTrack(MediaTrack): ...

class ChaptersTrack(Track):
    lang: Lang
    charset: Optional[str]
    def __init__(self, path: AnyPath, lang: Lang = ..., charset: Optional[str] = ..., *opts: str) -> None: ...

class _AbstractMatroskaFile(MutableSequence[Track], metaclass=abc.ABCMeta):
    @abstractmethod
    def __init__(self): ...
    @overload
    def __getitem__(self, index: int) -> Track: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[Track]: ...
    @overload
    def __setitem__(self, index: int, value: Track) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[Track]) -> None: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...
    def __len__(self) -> int: ...
    def insert(self, index: int, value: Track) -> None: ...

class SplitMode(str, Enum):
    SIZE: str
    DURATION: str
    TIMESTAMPS: str
    PARTS: str
    PARTS_FRAMES: str
    FRAMES: str
    CHAPTERS: str

class MatroskaFile(_AbstractMatroskaFile):
    global_opts: Tuple[str, ...]
    def __init__(self, output: AnyPath, tracks: Union[AnyPath, Track, Iterable[Union[AnyPath, Track]], None] = ..., *global_opts: str) -> None: ...
    @property
    def command(self) -> List[str]: ...
    @classmethod
    def autotrack(cls, file: FileInfo) -> MatroskaFile: ...
    @staticmethod
    def automux(file: FileInfo) -> None: ...
    @overload
    def mux(self, return_workfiles: Literal[True] = ...) -> CleanupSet: ...
    @overload
    def mux(self, return_workfiles: Literal[False]) -> None: ...
    def split(self, mode: SplitMode, param: str) -> None: ...
    def split_size(self, size: str) -> None: ...
    def split_duration(self, duration: str) -> None: ...
    def split_timestamps(self, timestamps: Iterable[str]) -> None: ...
    def split_parts(self, parts: List[Tuple[Union[str, None], Union[str, None]]]) -> None: ...
    def split_parts_frames(self, parts: List[Tuple[Union[int, None], Union[int, None]]]) -> None: ...
    def split_frames(self, frames: Union[int, Iterable[int]]) -> None: ...
    def split_chapters(self, indices: Union[Literal['all'], Iterable[int]]) -> None: ...
    def append_to(self, files: Iterable[AnyPath], ids: Union[Iterable[Tuple[int, int, int, int]], None] = ...) -> None: ...
    def add_timestamps(self, path: AnyPath, id_: int = ...) -> None: ...
    def add_attachments(self) -> NoReturn: ...
