import loguru
from ..types import F
from .abstract import Singleton
from typing import Any, Callable, ContextManager, NamedTuple, NoReturn, overload

class LogLevel(NamedTuple):
    name: str
    no: int
    colour: str

class Logger(Singleton):
    def __init__(self) -> None: ...
    @property
    def logger(self) -> loguru.Logger: ...
    @property
    def level(self) -> int: ...
    def set_level(self, level: int) -> None: ...
    def logo(self) -> None: ...
    def trace(self, message: Any, depth: int = ..., **kwargs: Any) -> None: ...
    def debug(self, message: Any, depth: int = ..., **kwargs: Any) -> None: ...
    def info(self, message: Any, depth: int = ..., **kwargs: Any) -> None: ...
    def success(self, message: Any, depth: int = ..., **kwargs: Any) -> None: ...
    def warning(self, message: Any, depth: int = ..., **kwargs: Any) -> None: ...
    def error(self, message: Any, exception: Union[bool, BaseException, None] = ..., depth: int = ..., record: bool = ..., **kwargs: Any) -> NoReturn: ...
    def critical(self, message: Any, exception: Union[bool, BaseException, None] = ..., depth: int = ..., record: bool = ..., **kwargs: Any) -> NoReturn: ...
    @overload
    def catch(self, func: F) -> F: ...
    @overload
    def catch(self, **kwargs: Any) -> Callable[[F], F]: ...
    def catch_ctx(self) -> ContextManager[None]: ...

logger: Logger
